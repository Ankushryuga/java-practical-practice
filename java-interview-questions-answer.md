## Java Platform Questions:
# Bytecode:
    => Java bytecode is an intermediate, low-level, and platform-independent code generated by the Java compiler when Java source code is compiled.

# Platform Independence in java?
    => a compiled Java program (bytecode) can run on any operating system that has a Java Virtual Machine (JVM).

# Classloader?
    => its a JRE component that dynamically loads java class to JVM, When a Java program runs, not all classes are loaded into memory at once; instead, 
       they are loaded on demand as needed. This on-demand loading is managed by the ClassLoader.

# Wrapper classes?
    => Its a set of classes, that allow primitive data types to be created as an objects. 

# Why do we need wrapper classes in java?
    => for converting primitive data types into objects, enabling compatiblity with java oops, collections and generics.

# Different ways of creating wrapper classes instances?
    => 
    1. through constructor (but not recommended: the reason is whenever we create an instance using a constructor, new memory get allocated in the heap, it contradicts the imuutability of instances of the wrapper classes.)
    syntax: nameOfClass nameOfObject=new nameOfClass(value);

    2. Through valueOfMethod: it is a static method that takes one or two arguments according to the need and encapsulates the primitve type into corresponding wrapper class object.
    syntax: nameOfClass nameOfObject=nameOfClass.valueOf(value);

    3. Through ClassName: using new keywoord or constructor, its called autoboxing as the conversion from primitves to their corresponding classes id done automatically.
    syntax: nameOfClass nameOfObject=value;

# Autoboxing?
    => 
    converting primitive data type to their wrapper classes is called autoboxing, by default its done by java compiler
# Unboxing?
    => converting an object of a wrapper type (Integer) to its corresponding primitive int value is called unboxing.
# Casting?
    => it means assigning a value of one primitve data type to another type.
    1. Widening casting (automatically)  -> converting a smaller type to a larger type size.
        => byte -> short -> char -> int -> long -> float -> double.
    2. Narrowing casting (manually) -> converting a larger type to a smaller size type.
        => double-> float-> long-> int-> char-> short-> byte.

        Example:
        int myInt=6;
        double myDouble=myInt;  //Automatic casting.

        double myDouble=8.53d;
        int myInt=(int)myDouble;  //manual.

# why strings are immutable in java?
    => strings are treated as objects in java, the term immutable strings means: a String object that cannot be altered, but reference to the object can be changed, every time we make a modification, a new instance of that string gets created, so string marked as final.

# where are string values stored in memory in java?
    => since strings are like other objects, are stored in heap.

# Why should you be careful about String concatenation(+) operator in loops?
    => it can lead to inefficient memory usage and poor performance, and string are immutables.

# this problem can be solved with string StringBuilder( if thread-safety need and these are mutable.)
    => 
      StringBuilder result=new StringBuilder();
      for(int i=0;i<100;i++){
        result.append("a");
      }

# string vs stringbuilder vs stringbuffer.
    =>
    1. String: immutable, No thread-safe, slow in loops,
    2. StringBuilder: mutable, No thread-safe, fastest, 
    3. StringBuffer: mutable, Yes(synchronized), slower, mutlithread apps.
    
# String methods:
    => length(), charAt(int index), substring(int beginIndex), substring(int begin, int end),  equals(String another), equalsIgnoreCase(String another), compareTo, toLowerCase()/toUpperCase(), trim() etc.

# Java OOPS:
    => 
    1. class: its like an object constructor, or a "blueprint" for creating objects.
    2. object: its a basic unit of oop and represents real-life entities, objects are the instances of a class that are created to use the attributes and method of a class.

# What is the state of an object?
    => it refers to the set of values stored in its instance variables at any given time during program execution.

# super class of every class in java?
    => object class.
    
# Hashcode method in java?
    => its a native method and returns the integer hash code value of the object.

# Can super class reference variable can hold an object of sub class?



